# word search
**回溯法解决：对board中每一个位置进行一次回溯**

``` cpp
class Solution {
public:
    bool exist(vector<vector<char>>& board, string word) {
        vector<vector<int>> visited(board.size(), vector<int>(board[0].size(), 0));
        for (int i = 0; i < board.size(); i++)
            for (int j = 0; j < board[0].size(); j++)
                if (backtrace(board, visited, i, j, 0, word)) return true;
        return false;
    }
    bool backtrace(vector<vector<char>>& board, vector<vector<int>>& visited, int i, int j, int curNum, const std::string& target) {
        if (i < 0 || i >= board.size() || j < 0 || j >= board[0].size()
            || target[curNum] != board[i][j] || visited[i][j] == 1) return false;
        if (curNum == target.size()-1) return true;
        visited[i][j] = 1;
        if (backtrace(board, visited, i+1, j, curNum+1, target) || backtrace(board, visited, i-1, j, curNum+1, target) || backtrace(board, visited, i, j+1, curNum+1, target) || backtrace(board, visited, i, j-1, curNum+1, target)) return true;
        visited[i][j] = 0;
        return false;
     }
};
```

# word search ii
# word search ii
**思路：对每一个word进行一次word search判断**
``` cpp
class Solution {
public:
    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
        set<string> results;
        
        for (auto word : words) {
            vector<vector<int>> visited(board.size(), vector<int>(board[0].size(), 0));
            for (int i = 0; i < board.size(); i++) {
                for (int j = 0; j < board[0].size(); j++) {
                    if (backstrace(board, word, visited, i, j, 0)){
                        results.insert(word);
                    }
                }
            }
        }

        return vector<string>(results.begin(), results.end());
    }
private:
    bool backstrace(vector<vector<char>>& board, string& words, vector<vector<int>>& visited, int i, int j, int cur) {
        if (i < 0 || i >= board.size() || j < 0 || j >= board[0].size() || visited[i][j] == 1 || board[i][j] != words[cur]) {
            return false;
        }
        
        if (cur == words.size()-1) return true;
        
        visited[i][j] = 1;
        if (backstrace(board,words,visited,i+1,j,cur+1) || backstrace(board,words,visited,i-1,j,cur+1) || backstrace(board,words,visited,i,j+1,cur+1) || backstrace(board,words,visited,i,j-1,cur+1))
            return true;
        visited[i][j] = 0;
        return false;
        
    }
};
```

**思路：采用trie树优化**
``` cpp
struct TrieNode {
    TrieNode() : next(26, nullptr) {}
    vector<TrieNode*> next;
    string word;
};
class Solution {
public:
    vector<string> findWords(vector<vector<char>>& board, vector<string>& words) {
        vector<string> results;
        TrieNode* root = buildTrie(words);
        for (int i = 0; i < board.size(); i++) {
            for (int j = 0; j < board[0].size(); j++) {
                 backstrace(board, root, results, i, j);
            }
        }
    
        return results;
    }
private:
    TrieNode* buildTrie(vector<string>& words) {
        TrieNode* root = new TrieNode();
        for (auto word : words) {
            TrieNode* p = root;            
            for (auto ch : word) {
                if (p->next[ch-'a'] == nullptr) {
                    p->next[ch-'a'] = new TrieNode();
                }
                p = p->next[ch-'a'];
            }
            p->word = word;
        }
        return root;
    }

    void backstrace(vector<vector<char>>& board, TrieNode* root, vector<string>& results, int i, int j) {
        char ch = board[i][j];
        if (ch == '#' || root->next[ch-'a'] == nullptr) return;
        root = root->next[ch-'a'];
        string& word = root->word;
        if (!word.empty()) {
            results.push_back(word);
            word.clear();
        }
        
        board[i][j] = '#';
        if (i < board.size()-1) backstrace(board, root, results, i+1, j);
        if (j < board[0].size()-1) backstrace(board, root, results, i, j+1);
        if (i > 0) backstrace(board, root, results, i-1, j);
        if (j > 0) backstrace(board, root, results, i, j-1);
        board[i][j] = ch;
    }
};
```