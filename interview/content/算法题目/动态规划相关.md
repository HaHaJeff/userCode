#  word_break
**判断字符串s是否是由wordDict中的word组成，wordDict中的word可以被用多次**
**dp[i]表示以i结尾的字符串可否满足上述条件，dp[i]为true的条件是：j ->[0, i-1]中   dp[j] && s.substr(j, i-j)在wordDict中出现**

``` cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> dict(wordDict.begin(), wordDict.end());
        vector<int> dp(s.size()+1);
        dp[0] = 1;
        for(int i = 1; i <= s.size(); i++) {
            for (int j = i-1; j >= 0; j--) {
                if (dp[j] && dict.find(s.substr(j, i-j)) != dict.end())
                {
                    dp[i] = 1;
                    break;
                }
            }
        }
        return dp[s.size()];
    }
};
```

# word break ii

**回溯法+备忘录可以解决**

``` cpp
Example 1:
Input:
s = "catsanddog"
wordDict = ["cat", "cats", "and", "sand", "dog"]
Output:
[
  "cats and dog",
  "cat sand dog"
]

Example 2:
Input:
s = "pineapplepenapple"
wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]
Output:
[
  "pine apple pen apple",
  "pineapple pen apple",
  "pine applepen apple"
]
Explanation: Note that you are allowed to reuse a dictionary word.

Example 3:
Input:
s = "catsandog"
wordDict = ["cats", "dog", "sand", "and", "cat"]
Output:
[]
```

**思路：采用backstrace，可以完成，但是超时**
``` cpp
class Solution {
public:
    vector<string> wordBreak(string s, vector<string>& wordDict) {
        if (s.empty()) return vector<string>();
        vector<string> result;
        if (find(wordDict.begin(), wordDict.end(), s) != wordDict.end())
            result.push_back(s);
        for (int i = 1; i <= s.size(); i++) {
            string left = s.substr(0, i);
            if (find(wordDict.begin(), wordDict.end(), left) != wordDict.end()) {
                string right = s.substr(i);
                vector<string> next = wordBreak(right, wordDict);
                
                for (auto str : next) {  
                    result.push_back(left + " " + str);    
                }
            }
        }
        
        return result;
    }
};
```
**优化**
``` cpp
class Solution {
private:
    std::unordered_map<string, vector<string>> cache;
public:
    vector<string> wordBreak(string s, vector<string>& wordDict) { 
        if (s.empty()) return {""};
        if (cache.find(s) != cache.end()) return cache[s];
        vector<string> result;
        for (auto& str : wordDict) {
            if (s.substr(0, str.size()) != str) continue;
            vector<string> res = wordBreak(s.substr(str.size()), wordDict);
            for (auto& r : res) {
                result.push_back(str+(r.empty()?"":" ")+r);
            }
        } 
        cache[s] = result;
        return result;
    }
};
```

# wiggle subsequence

```cpp
Example 1:
Input: [1,7,4,9,2,5]
Output: 6
Explanation: The entire sequence is a wiggle sequence.

Example 2:
Input: [1,17,5,10,13,15,10,5,16,8]
Output: 7
Explanation: There are several subsequences that achieve this length. One is [1,17,10,13,10,16,8].

Example 3:
Input: [1,2,3,4,5,6,7,8,9]
Output: 2
```

**思路：dp解决，up[i]记录到i为止,i>i-1时满足条件的序列长度，down[i]记录到i为止i<i-1时满足条件的序列长度**

| -    | 2    | 1    | 2    | 3    | 4    | 3    | 2    | 1    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| up   | 1    | 1    | 3    | 3    | 3    | 3    | 3    | 3    |
| down | 1    | 2    | 2    | 2    | 2    | 4    | 4    | 4    |

**这俨然已经成为了一个dp问题，不过需要对上述两种情况都需要算**

- 因为计算dp[i]时有两种可能
  - i > i-1，说明目前处在上身阶段，那么i的最长长度一定为到 i-1 处于下降阶段的数值+1
  - i < i-1，与上述情况相反

```cpp
class Solution {
public:
    int wiggleMaxLength(vector<int>& nums) {
        if (nums.empty()) return 0;
        vector<int> up(nums.size());
        vector<int> down(nums.size());
        up[0] = 1;
        down[0] = 1;  
        for (int i = 1; i < nums.size(); i++) {
            if (nums[i] > nums[i-1]) {
                up[i] = down[i-1] + 1;
                down[i] = down[i-1];
            } else if (nums[i] < nums[i-1]) {
                down[i] = up[i-1] + 1;
                up[i] = up[i-1];
            } else {
                down[i] = down[i-1];
                up[i] = up[i-1];
            }
        }
        return max(up[nums.size()-1], down[nums.size()-1]);
    }
};
```

# unique string in wraparound string
- 统计p中独一无二字符串的个数， p[i] == p[i-1]+1 || i == 0
``` cpp
class Solution {
public:
    // dp: dp[i]表示以p[i]结尾的满足条件的个数
    int findSubstringInWraproundString(string p) {
        vector<int> dp(26 , 0);
        int maxLength = 0;
        for (int i = 0; i < p.size(); i++) {
            if (i > 0 && (p[i] - p[i-1] == 1 || p[i-1]-p[i] == 25)) {
                maxLength++;
            } else {
                maxLength = 1;
            }
            dp[p[i]-'a'] = max(maxLength, dp[p[i]-'a']);
        }
        int ans = 0;
        for (int i = 0; i < dp.size(); i++) ans += dp[i];
        return ans;
    }
};
```