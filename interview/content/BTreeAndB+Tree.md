# B树家族
B树和B+作为一种平衡树，能够保持数据有序。这种数据结构能够让查找数据，顺序访问，插入数据以及删除的动作都能在对数时间内完成。B树等为系统大块数据的读写操作做了优化，减少了定位记录时所经历的中间过程，从而加速存取。

## B树
t为树的最小度数，B树或为空树，否则满足下列条件：
1. 所有的叶子节点在同一层
2. 除根节点之外的的所有节点至少包含t-1个keys，至多包含2t-1个keys **当内部节点包含2t-1个keys时，分裂**

# B+树

与B树的不同之处在于

- 内部节点只会保存索引信息，具体的数据保存在叶子节点，也就说结果内容可能会出现重复
- 叶子节点通常会通过链表连接起来，方便range查询

B+树相比于B树的优势在于：

- B+树的内部节点不保存树，所以一个page能够容纳更多的index
- B+树查询必须查找到叶子节点，但是B树只要匹配到即可，因此B+树查找效率更加稳定
- 对于范围查找来说，B+树只需要遍历叶子节点链表即可，而B树却需要中序遍历
- 如果数据局部性很强，B树的查找可能会更加好，一位数据以及索引在同一页中

# 数据库索引

- B树索引
  - 普通索引 
    - CREATE INDEX 索引名 ON 表明(列名1...列名n)
    - 修改表： ALTER TABLE 表名 ADD INDEX 索引名(列名1...列名n)
    - 创建表时制定索引：CREATE TABLE 表明([...], INDEX 索引名(列名1...列名n))
  - UNIQUE索引 表示唯一的，不允许重复的索引，如果该字段信息不会重复（例如身份证号）
    - CREATE UNIQUE INDEX 索引名 ON 表明(列名1...列名n)
    - 修改表： ALTER TABLE 表名 ADD UNIQUE  INDEX 索引名(列名1...列名n)
    - 创建表时制定索引：CREATE TABLE 表明([...], UNIQUE  INDEX 索引名(列名1...列名n))
  - 主键：PRIMARY KEY索引  主键是一种唯一性索引
    - 主键一般在创建表的时候指定
    - 也可以通过修改表的方式
- HASH索引
  - Hash索引只能用于对等比较，例如=,<=>（相当于=）操作符。由于是一次定位数据，不像BTree索引需要从根节点到枝节点，最后才能访问到页节点这样多次IO访问，所以检索效率远高于BTree索引。 
  - 但为什么我们使用BTree比使用Hash多呢？主要Hash本身由于其特殊性，也带来了很多限制和弊端： 
    1. Hash索引仅仅能满足“=”,“IN”,“<=>”查询，不能使用范围查询。 
    2. 联合索引中，Hash索引不能利用部分索引键查询。 
      对于联合索引中的多个列，Hash是要么全部使用，要么全部不使用，并不支持BTree支持的联合索引的最优前缀，也就是联合索引的前面一个或几个索引键进行查询时，Hash索引无法被利用。 
    3. Hash索引无法避免数据的排序操作 
      由于Hash索引中存放的是经过Hash计算之后的Hash值，而且Hash值的大小关系并不一定和Hash运算前的键值完全一样，所以数据库无法利用索引的数据来避免任何排序运算。 
    4. Hash索引任何时候都不能避免表扫描 
      Hash索引是将索引键通过Hash运算之后，将Hash运算结果的Hash值和所对应的行指针信息存放于一个Hash表中，由于不同索引键存在相同Hash值，所以即使满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要通过访问表中的实际数据进行比较，并得到相应的结果。 
    5. Hash索引遇到大量Hash值相等的情况后性能并不一定会比BTree高 
      对于选择性比较低的索引键，如果创建Hash索引，那么将会存在大量记录指针信息存于同一个Hash值相关联。这样要定位某一条记录时就会非常麻烦，会浪费多次表数据访问，而造成整体性能底下。

- R-Tree索引
- Full-text索引

# InnoDB
InnoDB是一个健壮的事务型存储引擎，这种存储引擎已经被很多互联网公司使用，为用户操作非常大的数据存储提供了一个强大的解决方案。我的电脑上安装的 MySQL 5.6.13 版，InnoDB就是作为默认的存储引擎。InnoDB还引入了行级锁定和外键约束，在以下场合下，使用InnoDB是最理想的选择：

- 更新密集的表。InnoDB存储引擎特别适合处理多重并发的更新请求。
- 事务。InnoDB存储引擎是支持事务的标准MySQL存储引擎。
- 自动灾难恢复。与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。
- 外键约束。MySQL支持外键的存储引擎只有InnoDB。
- 支持自动增加列AUTO_INCREMENT属性。
- 从5.7开始innodb存储引擎成为默认的存储引擎。
- 一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB是不错的选择。

# MyISAM
MyISAM表是独立于操作系统的，这说明可以轻松地将其从Windows服务器移植到Linux服务器；每当我们建立一个MyISAM引擎的表时，就会在本地磁盘上建立三个文件，文件名就是表名。例如，我建立了一个MyISAM引擎的tb_Demo表，那么就会生成以下三个文件：

- tb_demo.frm，存储表定义。
- tb_demo.MYD，存储数据。
- tb_demo.MYI，存储索引。

MyISAM表无法处理事务，这就意味着有事务处理需求的表，不能使用MyISAM存储引擎。MyISAM存储引擎特别适合在以下几种情况下使用：

- 选择密集型的表。MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。
- 插入密集型的表。MyISAM的并发插入特性允许同时选择和插入数据。例如：MyISAM存储引擎很适合管理邮件或Web服务器日志数据。
- MRG_MYISAM
  MRG_MyISAM存储引擎是一组MyISAM表的组合，老版本叫 MERGE 其实是一回事儿，这些MyISAM表结构必须完全相同，尽管其使用不如其它引擎突出，但是在某些情况下非常有用。说白了，Merge表就是几个相同MyISAM表的聚合器；Merge表中并没有数据，对Merge类型的表可以进行查询、更新、删除操作，这些操作实际上是对内部的MyISAM表进行操作。

# MEMORY
使用MySQL Memory存储引擎的出发点是速度。为得到最快的响应时间，采用的逻辑存储介质是系统内存。虽然在内存中存储表数据确实会提供很高的性能，但当mysqld守护进程崩溃时，所有的Memory数据都会丢失。获得速度的同时也带来了一些缺陷。它要求存储在Memory数据表里的数据使用的是长度不变的格式，这意味着不能使用BLOB和TEXT这样的长度可变的数据类型，VARCHAR是一种长度可变的类型，但因为它在MySQL内部当做长度固定不变的CHAR类型，所以可以使用。

一般在以下几种情况下使用Memory存储引擎：

- 目标数据较小，而且被非常频繁地访问。在内存中存放数据，所以会造成内存的使用，可以通过参数max_heap_table_size控制Memory表的大小，设置此参数，就可以限制Memory表的最大大小。
- 如果数据是临时的，而且要求必须立即可用，那么就可以存放在内存表中。
- 存储在Memory表中的数据如果突然丢失，不会对应用服务产生实质的负面影响。
- Memory同时支持散列索引和B树索引。B树索引的优于散列索引的是，可以使用部分查询和通配查询，也可以使用<、>和>=等操作符方便数据挖掘。散列索引进行“相等比较”非常快，但是对“范围比较”的速度就慢多了，因此散列索引值适合使用在=和<>的操作符中，不适合在<或>操作符中，也同样不适合用在order by子句中。