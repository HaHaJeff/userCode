

- 要想让数据有高可用性，就得写多份数据
- 写多份的问题会导致数据一致性的问题
- 数据一致性的问题又会引发性能问题

# 强一致

新的数据一旦写入，在任意副本任意时刻都能读到新值。比如：文件系统，RDBMS，AzureTable都是强一致的。

# 弱一致性

当你写入一个新值后，读操作在数据副本上可能读出来，也可能读不出来。比如：某些cache系统，网络游戏其他玩家的数据和你没什么关系，VOIP这样的系统或者百度搜索引擎。

# 最终一致性

当你写入一个新值后，有可能无法立即读出来，但在某个时间窗口之后保证最终能读出来。比如：DNS，电子邮件，Amzaon S3，Google搜索引擎这样的系统。

**从三种一致性的模型来看，弱一致以及最终一致是异步冗余的，而Strong一般来说是同步冗余的，异步通常意味着更好的性能，但也意味着更复杂的状态控制。同步意味着简单，但也意味着性能下降。**

# Master-Slave

slave作为master的备份。在这样的系统中，一般是如下设计的：

- 读写请求都由Mater负责
- 写请求写到Master上后，由Master同步到slave上

从Master同步到Slave上，你可以使用异步，也可以使用同步，可以使用Master来push，也可以使用slave来pull。通常来说是Slave来周期性的pull，所以是**最终一致性**。这个设计的问题是，如果Master在pull周期内垮掉了，那么会导致这个时间片内的数据丢失。如果不想丢失数据，slave只能采用Read-Only的方式等Master恢复。

当然Master-Slave也可以做成强一致的，如何做？Master先写自己，写完自己后不返回，再写slave，两者都成功后返回，整个过程是同步的，如果写slave失败了，那么两种方法：

- 标记slave不可用报错并继续提供服务（假设采用三副本的方式，失败的slave恢复后可以从Master上同步数据，正常的slave还是可以提供服务的哈）
- 回滚自己并返回写失败（这里感觉有点向2PC了，哈哈，这样相当于一个事务了。Master上的写请求要么在所有机器上写成功，要么全部写失败）

# Master-Master

指一个系统上存在两个或多个Master，每个Master都提供Read-Write服务。这个模型是Master-Slave的加强版，数据间同步一般是通过Master间的异步完成，所以是最终一致性。Master-Master的好处是：一台Master挂了，别的Master可以正常做读写服务，他和Master-Slave一样，当数据没有被复制到别的Master上时，数据会丢失。

另外，如果多个Master对同一个数据进行修改的时候，这个模型的噩梦就出现了——对数据间的冲突合并，这并不是一件容易的事情。

# 2PC——Two Phase Commit

在分布式系统中，**每个节点虽然可以知晓自己的操作是成功或失败，却无法直到其他节点的操作是成功或失败**。当一个事务跨越多个节点时，为了保持事务的**ACID**特定，需要引入一个作为协调者的组件来统一掌控所有节点的操作结果，并最终指示这些节点是否要把操作结果进行真正的提交。

- 第一阶段
  - 协调者会问所有的参与者节点，是否可以执行提交操作
  - 各个参与者开始执行事务的准备工作：如资源上锁，预留资源，写undo/redo log...
  - 参与者响应协调者，如果事务的准备工作成功，则回应“can commit”，否则回应"reduce commit"
- 第二阶段
  - 如果所有的参与者都回应“can commit”，那么，协调者向所有的参与者发送“正式提交“命令。参与者完成正式提交，并释放所有资源，然后回应”完成“，协调者收集各节点的”完成“回应后结束这个global transaction。
  - 如果有一个参与者回应”reduce commit“，那么，协调者向所有的参与者节点发送”回滚操作“。协调者完成回滚，并释放所有资源，然后回应”完成“，协调者收集各节点的”回滚“回应后，取消这个global transaction。

问题：

- 如果第一阶段中，参与者没有收到询问请求或是参与者的回应没有达到协调者。那么需要协调者做超时处理，一旦超时，可以当作失败也可以重试。
- 如果第二阶段中，参与者没有收到正式的请求(**commit 或 fallback**)或是参与者的回应没有达到协调者。那么需要协调者做超时处理，一旦超时，要么重试，要么将那个参与者节点删除。
- 最糟糕的情况是：在第二阶段中，如果协调者挂了，参与者完全不知道该怎么办(因为目前的集群可能是all yes或是all no或是部分yes部分no)。为了一致性，要么死等协调者，要么重新开始操作（所有参与者回滚，使用新的协调者或是等待其恢复）。

所以，两阶段提交的一个最大的问题是，严重依赖协调者，尤其是在第二阶段：如果参与者没有收到协调者的正式提交或回滚请求，参与者将block

# 3PC——Three Phase Commit

三阶段引入了一个新的阶段，prepare阶段：协调者向所有参与者询问是否可以接受这个事务，除非所有人都同意了，才进入下一步锁住资源，否则。。

三阶段提交在理论上减少了失败的风险，因为prepare阶段的出现会让所有处于之后阶段的参与者知道：其他参与者大概是能够执行commit的。所以，如果碰到了两阶段最严重的问题时，参与者不会不知所措，它们会照样提交，因为这大概率是会成功的，但是这同时也会增加数据的不一致性，因为参与者毕竟不能完成保证其他参与者执行是到底是commit还是fallback。

# ACID

原子性，一致性，隔离性，持久性

# CAP

Consistency一致性，Availability可用性，Partition tolerance分区容错性

# BASE

Basic Available基本可用性，Soft State状态（允许不同副本间的同步延时），Eventual Consistency最终一致性