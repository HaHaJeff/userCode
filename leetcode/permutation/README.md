#recursion_version
递归版本：
1-234 对234进行递归调用   1-324  1-423
1-2-34对34进行递归调用    1-3-42 1-4-32
1-2-3-4 start==end,Print 

2-134 对134进行递归调用
3-214 对214进行递归调用
4-231 对231进行递归调用
本质即为递归加循环，循环用于换位

#recursion_repeat_version
例如对于1223，需要在swap的时候判断在swap(arr, i, j)之间是否有重复字符，如果有
则直接结束这一次的调用。只对第一个2进行swap*(arr, 0, 1)

#loop_version
STL中的next_permutation
实现方式为
1234的下一个排列为1243 ==> 1324 ==> 1342...
方法为有尾向前遍历，先找到相邻的两个字符 34,然后从尾向前找到第一个大于3的字符
进行swap操作，最后reverse(4,...)
**为什么要reverse?**
因为找到的字符一定是<=4的，例如对于 1243而言，相邻的两个字符为24,3为第一个大于2的字符
swap之后==>1342，swap操作会将2放到4之后，所以reverse(4,...)可以找到下一个排列，可以发现
swap操作最多将2置换到4的位置。

