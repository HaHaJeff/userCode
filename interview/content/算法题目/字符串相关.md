# word subset
- 定义：如果b中的每一个字符在a中都出现了，那么说明b是a的subset
-  题目要求：B中的每一个b在A的某一个a都出现了，那么说b是a的subset

``` cpp
class Solution {
public:
    vector<string> wordSubsets(vector<string>& A, vector<string>& B) {
        vector<string> results;
        vector<int> chA(26);
        vector<int> chB(26);
        vector<int> chTmp(26); 
        //记录B中字符出现的最大次数即可了，包含最大的一定包含你懂的
        for (string& b : B) {
            chTmp = counter(b);
            for (int i = 0; i < 26; i++) {
                chB[i] = max(chB[i], chTmp[i]);
            }
        }
        int i = 0;
        for (string& a : A) {
            chA = counter(a);
            for ( i = 0; i < 26; i++) {
                if (chA[i] < chB[i]) break;
            }
            if (i == 26) results.push_back(a);
        } 
        return results;
    } 
    vector<int> counter(const string& b) {
        vector<int> chs(26);
        for (auto ch : b) {
            chs[ch-'a']++;
        }
        return chs;
    }
};
```

# valid parenthese

``` cpp
Example 1:
Input: "()"
Output: true

Example 2:
Input: "()[]{}"
Output: true

Example 3:
Input: "(]"
Output: false

Example 4:
Input: "([)]"
Output: false

Example 5:
Input: "{[]}"
Output: true
```

``` cpp
class Solution {
public:
    bool isValid(string s) {
        stack<char> st;
        for (auto ch : s) {
            switch(ch) {
                case '(': st.push(')'); break;
                case '{': st.push('}'); break;
                case '[': st.push(']'); break;
                case ')':
                case '}':
                case ']':if (st.empty() || st.top() != ch) return false; st.pop(); break;
            }
        }
        return st.empty();     
    }
};
```

# palindromic substrings

统计字符串中属于回文字符串的个数
```
Example 1:
Input: "abc"
Output: 3
Explanation: Three palindromic strings: "a", "b", "c".
 
Example 2:
Input: "aaa"
Output: 6
Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".
```
**思路：采用dp的方式可以解决，先对长度为0的字符串进行判断，然后1，2，3...n，dp[i][j]表示i开始，j结尾的字符串是不是回文，dp[i][j] = s[i] == s[j] : dp[i+1][j-1]**
``` cpp
class Solution {
public:
    int countSubstrings(string s) {
        const int n = s.size();
        int count = 0;
        vector<vector<int>> dp(n, vector<int>(n));
        for (int d = 0; d < n; d++) {
            for (int i = 0; i+d < n; i++) {
                int j = i+d;
                if (s[i] == s[j]) {
                    dp[i][j] = (i+1>=j-1) ? true : dp[i+1][j-1];
                    if (dp[i][j]) count++;
                }
            }
        }
        return count;
    }
};
```
**思路：**
- 长度为n的字符串一共有2*n-1个center
- string  "1 2 3" 
- center  12345
- 对于center 1而言，其left=right=0
- 对于center 2而言，其left=0，right=1
- 对于center 3而言，其left=1，right=1， 同时以3为center的字符串还包括left=0，right=2
- ...以此类推

``` cpp
class Solution {
public:
    int countSubstrings(string s) {
        const int n = s.size();
        int centerNum = 2*n-1;
        int count = 0;
        for (int i = 0; i <= centerNum; i++) {
            int left = i/2;
            int right = left+i%2;
            while (left >= 0 && right < n && s[left] == s[right]) {
                count++;
                left--;
                right++;
            }
        }
        return count;
    }
};
```

**思路：Manacher's 算法解决**
