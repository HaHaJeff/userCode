# Linux Read调用浅析

- 内核是如何Cache已经读取的文件数据？
  - 内核分配一个struct page对以及读取的数据进行存储
- 驱动从磁盘读取的数据是否会直接写到用户的缓冲区中？
  - 调用file_read_actor将内核缓冲区中的数据拷贝到用户缓冲区中 
- 内核是在哪个地方分配空间来存储将要读取的数据？
- read调用是在哪个地方将进程阻塞，直至读取数据结束？
- “zero copy”是如何实现的？

## 基本流程
1. 系统调用read()会触发相应的VFS(Virtual Filesystem Switch)函数，传递的参数有文件描述符和文件偏移量。
2. VFS确定请求的数据**是否已经在内存缓存中**；若数据不再内存中，确定如何执行读操作。
3. 假设内核必须从块设备上读取数据，这样内核就必须通过数据在物理设备上的位置。这由映射层(Mapping layer)来完成。
   1. 调用特定文件系统的get_block方式，首先确定文件偏移量对应的起始块号：偏移量为5000，则对应第一个块号
   2. 将上述的块号转换到磁盘的块号，**注意：文件在磁盘上不一定是连续的，此时inode中的i_blocks大显神通，i_blocks为一个15大小的数组，前12个直接对应磁盘块号**
4. 此时内核通过通用块设备层(Generic block layer)在块设备上执行读操作，启动IO操作，传输请求的数据。
5. 在通用块设备层之下是IO调度层，根据内核的调度策略，对IO等待队列排序。
6. 最后，块设备驱动(Block Device Driver)通过向磁盘控制器发送相应的命令，执行真正的数据传输。

# do_generic_file_read

​		该调用负责操作系统向底层磁盘设备读取page，这是一个通用接口，具体的调用由address_space对应的a_ops->readpage完成。

1. 获取filp(struct file*)的address_space字段，并以此获得inode字段

2. 根据ppos(文件指针位置，偏移量)，获得读取内容的起始页号index(*ppos>>PAGE_CACHE_SHIFT)，并获得在当前页中的偏移量(*ppos&~PAGE_CACHE_SHIFT)，这里同时还会获取预读状态

   1. 即使用户进程只读取1Byte，内核每次仍然会读取4096字节
   2. 如果文件本身小于4K怎么办？

3. 现在可以开始向磁盘读取page

   1. 先从address_space中找到第二步中获得的index对应的page，如果找到，开始步骤4
   2. 如果没有找到，则调用page_cache_sync_readahead(传说中的同步预读)，提交预读请求
   3. 再次去page_cache中查找(因为上一步的预读可能已经将其读到了cache中)
      1. 如果没有查找到，在address_space中分配一个新页
      2. 将page插入到address_space中
      3. 跳至3.6步
   4. 如果函数运行至此，说明读取的页已经位于page_cache中了，判断该page是否是通过预读读进来的，如果是，那么文件系统就要做一件牛逼的事情，发起异步预读。检查PG_uptodate是否置位，如果置位，说明page中的内容是最新的，因此无需从磁盘读数据，跳至3.7
   5. 页中的数据无效，必须从磁盘读取
   6. 开始真正的IO操作，调用address_space中的readpage方法**其实readpage调用的会表较少，因为预读的作用**，该函数负责激活磁盘到页之间的I/O数据传输
   7. 数据已经从磁盘被读取到了page中，需要将page中的数据拷贝到用户态
      1. **如果这里发现用户态的buf可以正常写，则使用临时内核映射完成copy(kmap_atomic)，完成之后判断是否已经copy完了，如果没有，则继续执行一下步骤，否则跳置7.5**
      2. 调用kmap()，该函数为处于ZONE_HIGHMEM内存中的页建立永久的内核映射(为什么要建立映射？**因为高端内存中的页框没有对应的线性地址**)。这里的言外之意是：如果page是ZONE_HIGHMEM中的，就建立，否则直接返回page的virtual字段（虚拟地址）。
      3. 调用cpoy_to_user()
      4. kunmap()解除永久内核映射
      5. 更新相应读写元数据

   # readpage

   将文件page对应的块号转换为磁盘对应的块号，从而开启磁盘读取。

   1. 如果该页是缓冲区页，也就是说该页与组成该页的块的缓冲区首部相关联。**这意味着该页过去已从磁盘读入过，而且页中的块在磁盘上不是相邻的**。跳至7
   2. 通过page->mapping->host->i_blkbits字段计算出访问该块需要的两个值：
      1. 页中的块数
      2. 第一块的文件块号（相对于文件起始位置页中的第一块的索引）
   3. 对于页中的每一块，调用特定文件系统的get_block函数，作为参数传递过去，得到逻辑块号（即相对于磁盘开始位置的快索引）。页中所有块的逻辑块号存放在一个本地数组中
   4. 如果上述块在磁盘上不相邻时，或某块落入“文件洞内”或一个块缓冲区已经由get_block函数写入时。跳至7
   5. 构造bio描述符，提交bio请求到I/O调度层
   6. 成功返回
   7. 一块一块进行读取
   8. 成功返回